/**
 * Apple-Inspired Network Visualization
 * 
 * A modern, elegant family network visualization following Apple's design principles
 * For Proof of Humanity application
 */

function createFamilyNetwork(containerId, options = {}) {
  // Default configuration with Apple-inspired aesthetics
  const config = {
    width: options.width || 800,
    height: options.height || 600,
    // Larger nodes for better visibility
    nodeRadius: options.nodeRadius || 30,
    labelFontSize: options.labelFontSize || 12,
    // Subtle drop shadows for depth
    shadowColor: 'rgba(0, 0, 0, 0.1)',
    shadowBlur: 10,
    shadowOffsetX: 0,
    shadowOffsetY: 3,
    // More subtle connection lines
    linkStrokeWidth: 2,
    linkDistance: options.linkDistance || 150,
    // Apple-like color palette
    colors: options.colors || {
      grandparent: '#FFB74D',  // Golden amber
      parent: '#9575CD',       // Soft purple
      child: '#64B5F6',        // Light blue
      verified: '#4CAF50',     // Success green
      pending: '#90A4AE',      // Neutral gray
      linkActive: 'rgba(100, 181, 246, 0.8)',
      linkInactive: 'rgba(224, 224, 224, 0.5)'
    },
    // Spring simulation parameters for smoother motion
    simulation: {
      alphaDecay: 0.02,
      velocityDecay: 0.4,
      chargeStrength: -800,
      linkStrength: 0.2
    },
    // Animation properties
    transitionDuration: 600,
    easingFunction: d3.easeCubicInOut,
    // Render options
    showLabels: options.showLabels !== undefined ? options.showLabels : true,
    interactive: options.interactive !== undefined ? options.interactive : true,
    // Use demo data if not provided
    useDemo: options.useDemo !== undefined ? options.useDemo : true
  };

  // Internal state
  let state = {
    svg: null,
    container: null,
    simulation: null,
    nodes: options.nodes || [],
    links: options.links || [],
    nodeElements: null,
    linkElements: null,
    zoomLevel: 1,
    transform: d3.zoomIdentity,
    selectedNode: null,
    highlightedPath: [],
    isZooming: false
  };

  // If no nodes/links provided, generate demo data
  if (state.nodes.length === 0 && state.links.length === 0 && config.useDemo) {
    generateDemoData();
  }

  // Initialize visualization
  init();

  /**
   * Initialize the visualization
   */
  function init() {
    // Get container element
    const containerElement = document.getElementById(containerId);
    if (!containerElement) {
      console.error(`Container with ID '${containerId}' not found`);
      return;
    }

    // Clear any existing content
    containerElement.innerHTML = '';
    
    // Set container styles
    containerElement.style.position = 'relative';
    containerElement.style.overflow = 'hidden';
    containerElement.style.width = '100%';
    containerElement.style.height = `${config.height}px`;
    containerElement.style.borderRadius = '12px';
    containerElement.style.backgroundColor = 'rgba(250, 250, 250, 0.8)';
    containerElement.style.boxShadow = 'inset 0 0 0 1px rgba(0, 0, 0, 0.05)';
    
    state.container = containerElement;

    // Create SVG element
    state.svg = d3.select(containerElement)
      .append('svg')
      .attr('width', '100%')
      .attr('height', '100%')
      .attr('viewBox', `0 0 ${config.width} ${config.height}`)
      .attr('class', 'apple-network-viz')
      .style('font-family', '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif');

    // Add defs for markers, filters, etc.
    createDefs();
    
    // Create the main group that will contain our visualization
    const mainGroup = state.svg.append('g')
      .attr('class', 'network-container');
    
    // Setup zoom behavior
    if (config.interactive) {
      const zoom = d3.zoom()
        .scaleExtent([0.5, 2.5])
        .on('zoom', (event) => {
          state.isZooming = true;
          state.transform = event.transform;
          mainGroup.attr('transform', event.transform);
          // Update zoomLevel for potential UI feedback
          state.zoomLevel = event.transform.k;
          // Debounce the zoom end event
          clearTimeout(state.zoomTimer);
          state.zoomTimer = setTimeout(() => {
            state.isZooming = false;
          }, 200);
        });
        
      state.svg.call(zoom);
      
      // Add double click to focus on node
      state.svg.on('dblclick.zoom', null); // Remove default zoom behavior
      
      // Add event listeners to container for custom events
      containerElement.addEventListener('reset-view', resetView);
      containerElement.addEventListener('zoom', handleZoom);
    }
    
    // Create link elements
    state.linkElements = mainGroup.append('g')
      .attr('class', 'links')
      .selectAll('path')
      .data(state.links)
      .enter()
      .append('path')
      .attr('class', 'link')
      .attr('stroke', d => d.verified ? config.colors.linkActive : config.colors.linkInactive)
      .attr('stroke-width', config.linkStrokeWidth)
      .attr('fill', 'none')
      .attr('opacity', 0.8)
      .attr('stroke-linecap', 'round');
    
    // Create node groups
    const nodeGroups = mainGroup.append('g')
      .attr('class', 'nodes')
      .selectAll('.node-group')
      .data(state.nodes)
      .enter()
      .append('g')
      .attr('class', 'node-group')
      .call(setupDragBehavior())
      .on('click', (event, d) => selectNode(d));
    
    // Add node circles with glass effect
    nodeGroups.append('circle')
      .attr('class', 'node-shadow')
      .attr('r', config.nodeRadius + 3)
      .attr('fill', 'none')
      .attr('filter', 'url(#shadow-filter)');
      
    nodeGroups.append('circle')
      .attr('class', 'node-base')
      .attr('r', config.nodeRadius)
      .attr('fill', d => getNodeColor(d))
      .attr('stroke', 'white')
      .attr('stroke-width', 2)
      .attr('filter', 'url(#glass-filter)');
      
    // Add verification icon
    nodeGroups.append('circle')
      .attr('class', 'verification-indicator')
      .attr('r', config.nodeRadius / 4)
      .attr('cx', config.nodeRadius * 0.6)
      .attr('cy', -config.nodeRadius * 0.6)
      .attr('fill', d => d.verified ? config.colors.verified : config.colors.pending)
      .attr('stroke', 'white')
      .attr('stroke-width', 1);
    
    // Add labels if enabled
    if (config.showLabels) {
      // Label background for better readability
      nodeGroups.append('rect')
        .attr('class', 'label-background')
        .attr('rx', 8)
        .attr('ry', 8)
        .attr('fill', 'rgba(255, 255, 255, 0.85)')
        .attr('filter', 'url(#label-shadow)')
        .attr('y', config.nodeRadius + 4)
        .attr('height', config.labelFontSize + 12);
        
      // Node label
      nodeGroups.append('text')
        .attr('class', 'node-label')
        .attr('text-anchor', 'middle')
        .attr('dominant-baseline', 'middle')
        .attr('y', config.nodeRadius + 10 + config.labelFontSize/2)
        .attr('fill', '#333')
        .attr('font-size', config.labelFontSize)
        .attr('font-weight', 500)
        .text(d => d.name || d.id);
    }
    
    // Store node elements for later use
    state.nodeElements = nodeGroups;
    
    // Update label background width based on text length
    const updateLabelBackground = () => {
      state.nodeElements.selectAll('.label-background')
        .attr('width', function() {
          const textWidth = this.parentNode.querySelector('.node-label').getBBox().width;
          return textWidth + 16;
        })
        .attr('x', function() {
          const width = parseFloat(this.getAttribute('width'));
          return -width/2;
        });
    };
    
    // Allow time for text to render before updating backgrounds
    setTimeout(updateLabelBackground, 0);
    
    // Setup force simulation
    state.simulation = d3.forceSimulation(state.nodes)
      // Link force with custom distance based on node relationship
      .force('link', d3.forceLink(state.links)
        .id(d => d.id)
        .distance(d => {
          // Make links between grandparent and parents shorter
          if (d.source.role === 'grandparent' || d.target.role === 'grandparent') {
            return config.linkDistance * 0.8;
          }
          // Make links between parents and children longer
          return config.linkDistance * 1.2;
        })
        .strength(config.simulation.linkStrength))
      // Charge force for node repulsion - stronger for grandparent
      .force('charge', d3.forceManyBody()
        .strength(d => {
          if (d.role === 'grandparent') return config.simulation.chargeStrength * 1.2;
          if (d.role === 'parent') return config.simulation.chargeStrength;
          return config.simulation.chargeStrength * 0.8;
        }))
      // Center force attracts nodes to the center, strong for grandparent
      .force('center', d3.forceCenter(config.width / 2, config.height / 2))
      // Collision force prevents node overlap
      .force('collision', d3.forceCollide().radius(config.nodeRadius * 1.5))
      // Custom positioning forces
      .force('x', d3.forceX().strength(d => {
        // Grandparent should be very centered
        if (d.role === 'grandparent') return 0.5;
        
        // Parents distributed in triangular pattern
        if (d.role === 'parent') {
          const parentIndex = state.nodes
            .filter(n => n.role === 'parent')
            .findIndex(n => n.id === d.id);
          const totalParents = state.nodes.filter(n => n.role === 'parent').length;
          
          // Calculate angle based on parent index (0, 1, 2) for triangular layout
          const angle = (2 * Math.PI * parentIndex) / totalParents;
          const radius = config.width * 0.2; // Distance from center
          
          // Custom position using trigonometry to create triangle
          const targetX = (config.width / 2) + radius * Math.cos(angle);
          
          // Create a force pulling toward this exact position
          return 0.3;
        }
        
        // Children positioned further out from their parent
        if (d.role === 'child') {
          // Get parent of this child
          const parentLink = state.links.find(link => 
            (link.target.id === d.id || (typeof link.target === 'string' && link.target === d.id)) &&
            (link.source.role === 'parent' || (typeof link.source !== 'object' && 
              state.nodes.find(n => n.id === link.source)?.role === 'parent'))
          );
          
          if (parentLink) {
            // Get parent node position (or will be positioned)
            const parentId = typeof parentLink.source === 'object' ? 
              parentLink.source.id : parentLink.source;
            const parentNode = state.nodes.find(n => n.id === parentId);
            
            if (parentNode) {
              // Find all children of this parent
              const siblings = state.links.filter(link => 
                (typeof link.source === 'object' ? link.source.id : link.source) === parentId &&
                (link.target.id !== d.id || (typeof link.target === 'string' && link.target !== d.id))
              );
              
              // Find index of this child among siblings
              const childIndex = state.links.filter(link => 
                (typeof link.source === 'object' ? link.source.id : link.source) === parentId
              ).findIndex(link => 
                (typeof link.target === 'object' ? link.target.id : link.target) === d.id
              );
              
              // Calculate angle for child position
              const baseAngle = (2 * Math.PI * 
                state.nodes.filter(n => n.role === 'parent').findIndex(n => n.id === parentId)
              ) / state.nodes.filter(n => n.role === 'parent').length;
              
              // Spread children around their parent
              const childAngle = baseAngle + 
                (((childIndex + 1) / (siblings.length + 1)) - 0.5) * Math.PI * 0.5;
              
              return 0.2;
            }
          }
        }
        
        return 0.1;
      }).x(d => {
        // Grandparent exactly in center
        if (d.role === 'grandparent') return config.width / 2;
        
        // Parents in triangle around grandparent
        if (d.role === 'parent') {
          const parentIndex = state.nodes
            .filter(n => n.role === 'parent')
            .findIndex(n => n.id === d.id);
          const totalParents = state.nodes.filter(n => n.role === 'parent').length;
          
          // Calculate angle for triangle layout
          const angle = (2 * Math.PI * parentIndex) / totalParents;
          const radius = config.width * 0.2;
          
          return (config.width / 2) + radius * Math.cos(angle);
        }
        
        // Children positioned based on their parent
        if (d.role === 'child') {
          // Find parent
          const parentLink = state.links.find(link => 
            (link.target.id === d.id || (typeof link.target === 'string' && link.target === d.id)) &&
            (link.source.role === 'parent' || (typeof link.source !== 'object' && 
              state.nodes.find(n => n.id === link.source)?.role === 'parent'))
          );
          
          if (parentLink) {
            const parentId = typeof parentLink.source === 'object' ? 
              parentLink.source.id : parentLink.source;
            const parentNode = state.nodes.find(n => n.id === parentId);
            
            if (parentNode) {
              // Find index among siblings
              const siblings = state.links.filter(link => 
                (typeof link.source === 'object' ? link.source.id : link.source) === parentId
              );
              
              const childIndex = siblings.findIndex(link => 
                (typeof link.target === 'object' ? link.target.id : link.target) === d.id
              );
              
              // Find parent's angle in the triangle
              const parentIndex = state.nodes
                .filter(n => n.role === 'parent')
                .findIndex(n => n.id === parentId);
              const totalParents = state.nodes.filter(n => n.role === 'parent').length;
              const parentAngle = (2 * Math.PI * parentIndex) / totalParents;
              
              // Outer radius for children
              const parentRadius = config.width * 0.2;
              const childRadius = config.width * 0.35;
              
              // Angle offset based on child index
              const angleOffset = ((childIndex - 1) * Math.PI / 6);
              
              return (config.width / 2) + childRadius * Math.cos(parentAngle + angleOffset);
            }
          }
        }
        
        return config.width / 2;
      }))
      .force('y', d3.forceY().strength(d => {
        // Grandparent should stick to center
        if (d.role === 'grandparent') return 0.5;
        
        // Parents in triangle
        if (d.role === 'parent') return 0.3;
        
        // Children positioned based on their parent
        if (d.role === 'child') return 0.2;
        
        return 0.1;
      }).y(d => {
        // Grandparent exactly in center
        if (d.role === 'grandparent') return config.height / 2;
        
        // Parents in triangle around grandparent
        if (d.role === 'parent') {
          const parentIndex = state.nodes
            .filter(n => n.role === 'parent')
            .findIndex(n => n.id === d.id);
          const totalParents = state.nodes.filter(n => n.role === 'parent').length;
          
          // Calculate angle for triangle layout
          const angle = (2 * Math.PI * parentIndex) / totalParents;
          const radius = config.height * 0.2;
          
          return (config.height / 2) + radius * Math.sin(angle);
        }
        
        // Children positioned based on their parent
        if (d.role === 'child') {
          // Find parent
          const parentLink = state.links.find(link => 
            (link.target.id === d.id || (typeof link.target === 'string' && link.target === d.id)) &&
            (link.source.role === 'parent' || (typeof link.source !== 'object' && 
              state.nodes.find(n => n.id === link.source)?.role === 'parent'))
          );
          
          if (parentLink) {
            const parentId = typeof parentLink.source === 'object' ? 
              parentLink.source.id : parentLink.source;
            const parentNode = state.nodes.find(n => n.id === parentId);
            
            if (parentNode) {
              // Find index among siblings
              const siblings = state.links.filter(link => 
                (typeof link.source === 'object' ? link.source.id : link.source) === parentId
              );
              
              const childIndex = siblings.findIndex(link => 
                (typeof link.target === 'object' ? link.target.id : link.target) === d.id
              );
              
              // Find parent's angle in the triangle
              const parentIndex = state.nodes
                .filter(n => n.role === 'parent')
                .findIndex(n => n.id === parentId);
              const totalParents = state.nodes.filter(n => n.role === 'parent').length;
              const parentAngle = (2 * Math.PI * parentIndex) / totalParents;
              
              // Outer radius for children
              const parentRadius = config.height * 0.2;
              const childRadius = config.height * 0.35;
              
              // Angle offset based on child index
              const angleOffset = ((childIndex - 1) * Math.PI / 6);
              
              return (config.height / 2) + childRadius * Math.sin(parentAngle + angleOffset);
            }
          }
        }
        
        return config.height / 2;
      }))
      .alphaDecay(config.simulation.alphaDecay)
      .velocityDecay(config.simulation.velocityDecay)
      .on('tick', updatePositions);
    
    // Initial update of positions
    updatePositions();
    
    // Custom event listeners for container
    if (config.interactive) {
      containerElement.addEventListener('focusNode', (e) => {
        const nodeId = e.detail?.nodeId;
        if (nodeId) {
          const node = state.nodes.find(n => n.id === nodeId);
          if (node) focusNode(node);
        }
      });
      
      containerElement.addEventListener('highlightPath', (e) => {
        const sourceId = e.detail?.sourceId;
        const targetId = e.detail?.targetId;
        if (sourceId && targetId) {
          highlightPath(sourceId, targetId);
        }
      });
    }
    
    // Add a subtle pulsing animation to the "You" node if it exists
    const youNode = state.nodes.find(n => n.name === 'You' || n.isCurrentUser);
    if (youNode) {
      const youNodeElement = state.nodeElements.filter(d => d.id === youNode.id);
      youNodeElement.select('.node-base')
        .style('animation', 'pulse 3s infinite');
    }
  }
  
  /**
   * Create SVG definitions for filters, markers, etc.
   */
  function createDefs() {
    const defs = state.svg.append('defs');
    
    // Glass effect filter
    const glassFilter = defs.append('filter')
      .attr('id', 'glass-filter')
      .attr('x', '-50%')
      .attr('y', '-50%')
      .attr('width', '200%')
      .attr('height', '200%');
    
    // Light reflection gradient
    glassFilter.append('feGaussianBlur')
      .attr('in', 'SourceAlpha')
      .attr('stdDeviation', '3')
      .attr('result', 'blur');
      
    glassFilter.append('feSpecularLighting')
      .attr('in', 'blur')
      .attr('surfaceScale', '5')
      .attr('specularConstant', '0.75')
      .attr('specularExponent', '20')
      .attr('lighting-color', '#FFFFFF')
      .attr('result', 'specular')
      .append('fePointLight')
      .attr('x', '-5000')
      .attr('y', '-10000')
      .attr('z', '20000');
      
    glassFilter.append('feComposite')
      .attr('in', 'specular')
      .attr('in2', 'SourceAlpha')
      .attr('operator', 'in')
      .attr('result', 'specular');
      
    glassFilter.append('feComposite')
      .attr('in', 'SourceGraphic')
      .attr('in2', 'specular')
      .attr('operator', 'arithmetic')
      .attr('k1', '0')
      .attr('k2', '1')
      .attr('k3', '1')
      .attr('k4', '0')
      .attr('result', 'glass');
    
    // Shadow filter
    const shadowFilter = defs.append('filter')
      .attr('id', 'shadow-filter')
      .attr('x', '-50%')
      .attr('y', '-50%')
      .attr('width', '200%')
      .attr('height', '200%');
      
    shadowFilter.append('feGaussianBlur')
      .attr('in', 'SourceAlpha')
      .attr('stdDeviation', '3')
      .attr('result', 'blur');
      
    shadowFilter.append('feOffset')
      .attr('in', 'blur')
      .attr('dx', '0')
      .attr('dy', '3')
      .attr('result', 'offsetBlur');
      
    shadowFilter.append('feComponentTransfer')
      .append('feFuncA')
      .attr('type', 'linear')
      .attr('slope', '0.2');
      
    const shadowMerge = shadowFilter.append('feMerge');
    shadowMerge.append('feMergeNode');
    shadowMerge.append('feMergeNode')
      .attr('in', 'SourceGraphic');
    
    // Label shadow
    const labelShadow = defs.append('filter')
      .attr('id', 'label-shadow')
      .attr('x', '-50%')
      .attr('y', '-50%')
      .attr('width', '200%')
      .attr('height', '200%');
      
    labelShadow.append('feDropShadow')
      .attr('dx', '0')
      .attr('dy', '1')
      .attr('stdDeviation', '1')
      .attr('flood-opacity', '0.2');
    
    // Hover effect
    const hoverFilter = defs.append('filter')
      .attr('id', 'hover-glow')
      .attr('x', '-50%')
      .attr('y', '-50%')
      .attr('width', '200%')
      .attr('height', '200%');
      
    hoverFilter.append('feGaussianBlur')
      .attr('stdDeviation', '2.5')
      .attr('result', 'coloredBlur');
      
    const hoverMerge = hoverFilter.append('feMerge');
    hoverMerge.append('feMergeNode')
      .attr('in', 'coloredBlur');
    hoverMerge.append('feMergeNode')
      .attr('in', 'SourceGraphic');
    
    // Selection effect
    const selectionFilter = defs.append('filter')
      .attr('id', 'selection-glow')
      .attr('x', '-50%')
      .attr('y', '-50%')
      .attr('width', '200%')
      .attr('height', '200%');
      
    selectionFilter.append('feGaussianBlur')
      .attr('stdDeviation', '5')
      .attr('result', 'coloredBlur');
      
    const selectionMerge = selectionFilter.append('feMerge');
    selectionMerge.append('feMergeNode')
      .attr('in', 'coloredBlur');
    selectionMerge.append('feMergeNode')
      .attr('in', 'SourceGraphic');
    
    // Pulse animation
    const style = document.createElement('style');
    style.textContent = `
      @keyframes pulse {
        0% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.85; transform: scale(1.05); }
        100% { opacity: 1; transform: scale(1); }
      }
      
      .node-group {
        transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      
      .node-group:hover {
        transform: scale(1.08);
      }
      
      .link {
        transition: stroke 0.3s ease, opacity 0.3s ease;
      }
    `;
    document.head.appendChild(style);
  }
  
  /**
   * Configure drag behavior for nodes
   */
  function setupDragBehavior() {
    if (!config.interactive) return function() {};
    
    return d3.drag()
      .on('start', (event, d) => {
        if (!event.active) state.simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
        d3.select(event.sourceEvent.currentTarget).select('.node-base')
          .style('filter', 'url(#hover-glow)');
      })
      .on('drag', (event, d) => {
        d.fx = event.x;
        d.fy = event.y;
      })
      .on('end', (event, d) => {
        if (!event.active) state.simulation.alphaTarget(0);
        // Allow fixed nodes to remain fixed
        if (!d.fixed) {
          d.fx = null;
          d.fy = null;
        }
        d3.select(event.sourceEvent.currentTarget).select('.node-base')
          .style('filter', 'url(#glass-filter)');
      });
  }
  
  /**
   * Update positions on each tick of the simulation
   */
  function updatePositions() {
    // Update link paths - use curved paths for aesthetics
    state.linkElements
      .attr('d', d => {
        const sourceX = typeof d.source === 'object' ? d.source.x : d.source.x;
        const sourceY = typeof d.source === 'object' ? d.source.y : d.source.y;
        const targetX = typeof d.target === 'object' ? d.target.x : d.target.x;
        const targetY = typeof d.target === 'object' ? d.target.y : d.target.y;
        
        // Determine if this is parent-child or sibling relationship
        const isVertical = Math.abs(sourceY - targetY) > Math.abs(sourceX - targetX);
        
        if (isVertical) {
          // For vertical relationships, use simple curved path
          const midY = (sourceY + targetY) / 2;
          return `M${sourceX},${sourceY} 
                  C${sourceX},${midY} ${targetX},${midY} ${targetX},${targetY}`;
        } else {
          // For horizontal relationships, use a more subtle curve
          return `M${sourceX},${sourceY} 
                  Q${(sourceX + targetX) / 2},${sourceY - 20} ${targetX},${targetY}`;
        }
      });
    
    // Update node positions
    state.nodeElements
      .attr('transform', d => `translate(${d.x}, ${d.y})`);
  }
  
  /**
   * Get the color for a node based on its role and status
   */
  function getNodeColor(node) {
    if (node.color) return node.color;
    
    // Color by role first
    if (node.role === 'grandparent') return config.colors.grandparent;
    if (node.role === 'parent') return config.colors.parent;
    if (node.role === 'child') return config.colors.child;
    
    // Fallback colors based on verification status
    return node.verified ? config.colors.verified : config.colors.pending;
  }
  
  /**
   * Focus the visualization on a specific node
   */
  function focusNode(node) {
    if (!node || !state.svg) return;
    
    // Highlight the node
    selectNode(node);
    
    // Animate to center on this node
    state.svg.transition()
      .duration(config.transitionDuration)
      .ease(config.easingFunction)
      .call(
        d3.zoom().transform,
        d3.zoomIdentity
          .translate(config.width / 2, config.height / 2)
          .scale(1.2)
          .translate(-node.x, -node.y)
      );
  }
  
  /**
   * Highlight the path between two nodes
   */
  function highlightPath(sourceId, targetId) {
    // Find nodes by ID
    const sourceNode = state.nodes.find(n => n.id === sourceId);
    const targetNode = state.nodes.find(n => n.id === targetId);
    
    if (!sourceNode || !targetNode) return;
    
    // Reset any existing highlights
    resetHighlights();
    
    // Find the path between these nodes
    const path = findPath(sourceNode, targetNode);
    state.highlightedPath = path;
    
    // Highlight the found path
    if (path.length > 0) {
      // Mark nodes in path
      const nodesInPath = new Set();
      nodesInPath.add(sourceId);
      nodesInPath.add(targetId);
      
      path.forEach(link => {
        const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
        const targetId = typeof link.target === 'object' ? link.target.id : link.target;
        nodesInPath.add(sourceId);
        nodesInPath.add(targetId);
      });
      
      // Dim nodes not in path
      state.nodeElements.classed('dimmed', d => !nodesInPath.has(d.id))
        .selectAll('.node-base')
        .attr('opacity', d => nodesInPath.has(d.id) ? 1 : 0.4);
      
      // Highlight links in path
      state.linkElements
        .attr('stroke', d => path.includes(d) ? config.colors.linkActive : config.colors.linkInactive)
        .attr('stroke-width', d => path.includes(d) ? config.linkStrokeWidth * 2 : config.linkStrokeWidth)
        .attr('opacity', d => path.includes(d) ? 1 : 0.3);
    }
  }
  
  /**
   * Find a path between two nodes using breadth-first search
   */
  function findPath(sourceNode, targetNode) {
    const visited = new Set();
    const queue = [{ node: sourceNode, path: [] }];
    
    while (queue.length > 0) {
      const { node, path } = queue.shift();
      const nodeId = node.id;
      
      if (nodeId === targetNode.id) {
        return path;
      }
      
      if (!visited.has(nodeId)) {
        visited.add(nodeId);
        
        // Find all connected links
        state.links.forEach(link => {
          const linkSourceId = typeof link.source === 'object' ? link.source.id : link.source;
          const linkTargetId = typeof link.target === 'object' ? link.target.id : link.target;
          
          if (linkSourceId === nodeId) {
            // From this node to another
            const nextNode = state.nodes.find(n => n.id === linkTargetId);
            queue.push({
              node: nextNode,
              path: [...path, link]
            });
          } else if (linkTargetId === nodeId) {
            // From another node to this one
            const nextNode = state.nodes.find(n => n.id === linkSourceId);
            queue.push({
              node: nextNode,
              path: [...path, link]
            });
          }
        });
      }
    }
    
    return []; // No path found
  }
  
  /**
   * Reset all highlights
   */
  function resetHighlights() {
    state.highlightedPath = [];
    
    // Reset nodes
    state.nodeElements.classed('dimmed', false)
      .selectAll('.node-base')
      .attr('opacity', 1);
    
    // Reset links
    state.linkElements
      .attr('stroke', d => d.verified ? config.colors.linkActive : config.colors.linkInactive)
      .attr('stroke-width', config.linkStrokeWidth)
      .attr('opacity', 0.8);
  }
  
  /**
   * Select a node, highlighting it
   */
  function selectNode(node) {
    // Deselect previous node
    if (state.selectedNode) {
      state.nodeElements
        .filter(d => d.id === state.selectedNode.id)
        .select('.node-base')
        .style('filter', 'url(#glass-filter)');
    }
    
    // If selecting the same node, deselect it
    if (state.selectedNode && state.selectedNode.id === node.id) {
      state.selectedNode = null;
      resetHighlights();
      return;
    }
    
    // Select new node
    state.selectedNode = node;
    
    state.nodeElements
      .filter(d => d.id === node.id)
      .select('.node-base')
      .style('filter', 'url(#selection-glow)');
    
    // Highlight direct connections
    const connectedLinks = state.links.filter(link => {
      const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
      const targetId = typeof link.target === 'object' ? link.target.id : link.target;
      return sourceId === node.id || targetId === node.id;
    });
    
    const connectedNodeIds = new Set();
    connectedNodeIds.add(node.id);
    
    connectedLinks.forEach(link => {
      const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
      const targetId = typeof link.target === 'object' ? link.target.id : link.target;
      connectedNodeIds.add(sourceId);
      connectedNodeIds.add(targetId);
    });
    
    // Highlight connected nodes and links
    state.nodeElements
      .selectAll('.node-base')
      .attr('opacity', d => connectedNodeIds.has(d.id) ? 1 : 0.4);
    
    state.linkElements
      .attr('stroke', d => {
        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
        const targetId = typeof d.target === 'object' ? d.target.id : d.target;
        return (sourceId === node.id || targetId === node.id) ? 
          config.colors.linkActive : config.colors.linkInactive;
      })
      .attr('stroke-width', d => {
        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
        const targetId = typeof d.target === 'object' ? d.target.id : d.target;
        return (sourceId === node.id || targetId === node.id) ? 
          config.linkStrokeWidth * 1.5 : config.linkStrokeWidth;
      })
      .attr('opacity', d => {
        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
        const targetId = typeof d.target === 'object' ? d.target.id : d.target;
        return (sourceId === node.id || targetId === node.id) ? 1 : 0.3;
      });
      
    // Dispatch custom event for additional UI updates
    if (state.container) {
      const event = new CustomEvent('nodeSelected', {
        detail: { node: node }
      });
      state.container.dispatchEvent(event);
    }
  }
  
  /**
   * Reset the view to show all nodes
   */
  function resetView() {
    // Clear any selection
    if (state.selectedNode) {
      selectNode(state.selectedNode); // Toggle selection off
    }
    
    // Reset highlights
    resetHighlights();
    
    // Reset zoom/pan
    state.svg.transition()
      .duration(config.transitionDuration)
      .call(
        d3.zoom().transform,
        d3.zoomIdentity
      );
      
    // Restart simulation
    state.simulation.alpha(0.3).restart();
  }
  
  /**
   * Handle zoom events from container
   */
  function handleZoom(event) {
    const direction = event.detail?.direction;
    if (!direction) return;
    
    const scaleFactor = direction === 'in' ? 1.2 : 0.8;
    
    state.svg.transition()
      .duration(200)
      .call(
        d3.zoom().scaleBy, 
        scaleFactor
      );
  }
  
  /**
   * Generate demo data for the family network
   */
  function generateDemoData() {
    // Create a family structure with grandparent -> parents -> children
    state.nodes = [
      // Grandparent (golden central node)
      { id: 'grandparent', name: 'Grandparent', role: 'grandparent', verified: true, fixed: true },
      
      // Parents (3 purple nodes)
      { id: 'parent1', name: 'Parent 1', role: 'parent', verified: true },
      { id: 'parent2', name: 'Parent 2', role: 'parent', verified: true },
      { id: 'parent3', name: 'Parent 3', role: 'parent', verified: true },
      
      // Children for Parent 1 (blue nodes)
      { id: 'child1-1', name: 'Child 1-1', role: 'child', verified: false },
      { id: 'child1-2', name: 'Child 1-2', role: 'child', verified: false },
      { id: 'child1-3', name: 'Child 1-3', role: 'child', verified: false },
      
      // Children for Parent 2 (blue nodes)
      { id: 'child2-1', name: 'Child 2-1', role: 'child', verified: false },
      { id: 'child2-2', name: 'Child 2-2', role: 'child', verified: false },
      { id: 'child2-3', name: 'Child 2-3', role: 'child', verified: false },
      
      // Children for Parent 3 (blue nodes)
      { id: 'child3-1', name: 'Child 3-1', role: 'child', verified: false },
      { id: 'child3-2', name: 'Child 3-2', role: 'child', verified: false },
      { id: 'child3-3', name: 'You', role: 'child', verified: false, isCurrentUser: true, fixed: false, highlighted: true }
    ];
    
    // Create connections between nodes to form the family tree
    state.links = [
      // Grandparent to Parents
      { source: 'grandparent', target: 'parent1', relationship: 'parent', verified: true },
      { source: 'grandparent', target: 'parent2', relationship: 'parent', verified: true },
      { source: 'grandparent', target: 'parent3', relationship: 'parent', verified: true },
      
      // Parent 1 to Children
      { source: 'parent1', target: 'child1-1', relationship: 'parent', verified: false },
      { source: 'parent1', target: 'child1-2', relationship: 'parent', verified: false },
      { source: 'parent1', target: 'child1-3', relationship: 'parent', verified: false },
      
      // Parent 2 to Children
      { source: 'parent2', target: 'child2-1', relationship: 'parent', verified: false },
      { source: 'parent2', target: 'child2-2', relationship: 'parent', verified: false },
      { source: 'parent2', target: 'child2-3', relationship: 'parent', verified: false },
      
      // Parent 3 to Children
      { source: 'parent3', target: 'child3-1', relationship: 'parent', verified: false },
      { source: 'parent3', target: 'child3-2', relationship: 'parent', verified: false },
      { source: 'parent3', target: 'child3-3', relationship: 'parent', verified: false }
    ];
  }
  
  // Public API
  return {
    // Get current state
    getState: () => ({
      nodes: state.nodes,
      links: state.links,
      selectedNode: state.selectedNode
    }),
    
    // Focus on a node
    focusNode: (nodeId) => {
      const node = state.nodes.find(n => n.id === nodeId);
      if (node) focusNode(node);
    },
    
    // Highlight a path
    highlightPath: (sourceId, targetId) => {
      highlightPath(sourceId, targetId);
    },
    
    // Reset the view
    resetView: () => {
      resetView();
    },
    
    // Update with new data
    update: (nodes, links) => {
      if (nodes) state.nodes = nodes;
      if (links) state.links = links;
      
      // Update the simulation
      state.simulation.nodes(state.nodes);
      state.simulation.force('link').links(state.links);
      
      // Restart the simulation
      state.simulation.alpha(1).restart();
    }
  };
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
  // Only initialize if container exists on the page
  if (document.getElementById('network-container')) {
    const networkViz = createFamilyNetwork('network-container', {
      useDemo: true,
      width: document.querySelector('.network-container').clientWidth || 800,
      height: 500
    });
  }
}); 