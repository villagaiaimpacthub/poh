/**
 * Network Visualization
 * 
 * Creates an interactive, organic family network visualization using D3.js
 * For Proof of Humanity application
 */

function createNetworkVisualization(containerId, options = {}) {
  // Default configuration
  const config = {
    width: options.width || 800,
    height: options.height || 600,
    nodeRadius: options.nodeRadius || 25,
    nodePadding: options.nodePadding || 10,
    linkDistance: options.linkDistance || 100,
    linkStrength: options.linkStrength || 0.7,
    chargeStrength: options.chargeStrength || -300,
    colors: options.colors || {
      primary: '#5575e7',
      secondary: '#a26bf3',
      verified: '#34d399',
      unverified: '#f87171',
      pending: '#fbbf24',
      link: 'rgba(148, 163, 184, 0.5)'
    },
    initialTransform: options.initialTransform || { x: 0, y: 0, k: 1 },
    autoPlay: options.autoPlay !== undefined ? options.autoPlay : true,
    showLabels: options.showLabels !== undefined ? options.showLabels : true,
    pulseAnimation: options.pulseAnimation !== undefined ? options.pulseAnimation : true,
    interactive: options.interactive !== undefined ? options.interactive : true
  };

  // Setup state
  let state = {
    nodes: options.nodes || generateDemoNodes(),
    links: options.links || generateDemoLinks(),
    simulation: null,
    svg: null,
    g: null,
    zoom: null,
    linkElements: null,
    nodeElements: null,
    labelElements: null
  };

  // Initialize the visualization
  initialize();

  // Creates the SVG container and sets up initial zooming
  function initialize() {
    // Create container if it doesn't exist
    const container = document.getElementById(containerId);
    if (!container) {
      console.error(`Container with ID '${containerId}' not found`);
      return;
    }

    // Clear any existing content
    container.innerHTML = '';

    // Set container size
    container.style.width = '100%';
    container.style.height = `${config.height}px`;
    container.style.position = 'relative';
    container.style.overflow = 'hidden';

    // Create SVG element
    state.svg = d3.select(container)
      .append('svg')
      .attr('width', '100%')
      .attr('height', '100%')
      .attr('viewBox', `0 0 ${config.width} ${config.height}`)
      .attr('class', 'network-visualization');

    // Define zoom behavior
    state.zoom = d3.zoom()
      .scaleExtent([0.2, 5])
      .on('zoom', (event) => {
        state.g.attr('transform', event.transform);
      });

    // Apply zoom behavior to SVG
    if (config.interactive) {
      state.svg.call(state.zoom);
    }

    // Add a group for all elements to enable zooming
    state.g = state.svg.append('g')
      .attr('class', 'network-container');

    // Add definitions for markers (arrows)
    const defs = state.svg.append('defs');
    
    // Add gradient for nodes
    const gradient = defs.append('radialGradient')
      .attr('id', 'node-gradient')
      .attr('cx', '50%')
      .attr('cy', '50%')
      .attr('r', '50%');
    
    gradient.append('stop')
      .attr('offset', '0%')
      .attr('stop-color', config.colors.primary);
    
    gradient.append('stop')
      .attr('offset', '100%')
      .attr('stop-color', config.colors.secondary);

    // Add filters for glow effects
    const filter = defs.append('filter')
      .attr('id', 'glow')
      .attr('x', '-50%')
      .attr('y', '-50%')
      .attr('width', '200%')
      .attr('height', '200%');
    
    filter.append('feGaussianBlur')
      .attr('stdDeviation', '3')
      .attr('result', 'coloredBlur');
    
    const feMerge = filter.append('feMerge');
    feMerge.append('feMergeNode')
      .attr('in', 'coloredBlur');
    feMerge.append('feMergeNode')
      .attr('in', 'SourceGraphic');
    
    // Create links
    state.linkElements = state.g.append('g')
      .attr('class', 'links')
      .selectAll('line')
      .data(state.links)
      .enter()
      .append('line')
      .attr('stroke', config.colors.link)
      .attr('stroke-width', d => d.strength ? 2 + d.strength : 2)
      .attr('stroke-dasharray', d => d.verified ? 'none' : '5,5');

    // Create node groups
    const nodeGroups = state.g.append('g')
      .attr('class', 'nodes')
      .selectAll('.node')
      .data(state.nodes)
      .enter()
      .append('g')
      .attr('class', 'node')
      .call(setupDrag());

    // Add circles to nodes
    nodeGroups.append('circle')
      .attr('r', config.nodeRadius)
      .attr('fill', d => getNodeColor(d))
      .attr('stroke', '#ffffff')
      .attr('stroke-width', 2)
      .attr('class', d => {
        let classes = 'node-circle';
        if (config.pulseAnimation && d.pulse) {
          classes += ' pulse';
        }
        return classes;
      })
      .style('filter', d => d.highlighted ? 'url(#glow)' : 'none');

    // Add verification indicator
    nodeGroups.append('circle')
      .attr('r', 8)
      .attr('cx', config.nodeRadius - 8)
      .attr('cy', config.nodeRadius - 8)
      .attr('fill', d => {
        if (d.verified) return config.colors.verified;
        if (d.pending) return config.colors.pending;
        return config.colors.unverified;
      })
      .attr('stroke', '#ffffff')
      .attr('stroke-width', 1.5);

    // Add verification icon
    nodeGroups.append('text')
      .attr('x', config.nodeRadius - 8)
      .attr('y', config.nodeRadius - 4)
      .attr('text-anchor', 'middle')
      .attr('font-family', 'sans-serif')
      .attr('font-size', '10px')
      .attr('fill', '#ffffff')
      .text(d => {
        if (d.verified) return '✓';
        if (d.pending) return '⏱';
        return '!';
      });

    // Add image (avatar) if available
    nodeGroups.filter(d => d.image)
      .append('image')
      .attr('xlink:href', d => d.image)
      .attr('x', -config.nodeRadius + 6)
      .attr('y', -config.nodeRadius + 6)
      .attr('width', (config.nodeRadius - 3) * 2)
      .attr('height', (config.nodeRadius - 3) * 2)
      .attr('clip-path', 'circle()');

    // Add labels if enabled
    if (config.showLabels) {
      // Label background for better readability
      nodeGroups.append('rect')
        .attr('x', -config.nodeRadius - 5)
        .attr('y', config.nodeRadius + 5)
        .attr('width', (config.nodeRadius + 5) * 2)
        .attr('height', 20)
        .attr('rx', 10)
        .attr('ry', 10)
        .attr('fill', 'rgba(255, 255, 255, 0.8)');
      
      // Text label
      nodeGroups.append('text')
        .attr('x', 0)
        .attr('y', config.nodeRadius + 18)
        .attr('text-anchor', 'middle')
        .attr('font-family', 'sans-serif')
        .attr('font-size', '12px')
        .attr('font-weight', '500')
        .attr('fill', '#1e293b')
        .text(d => d.name);
    }

    // Set nodes to state
    state.nodeElements = nodeGroups;

    // Create force simulation
    state.simulation = d3.forceSimulation(state.nodes)
      .force('link', d3.forceLink(state.links)
        .id(d => d.id)
        .distance(d => d.verified ? config.linkDistance * 0.8 : config.linkDistance)
        .strength(config.linkStrength))
      .force('charge', d3.forceManyBody()
        .strength(d => d.role === 'grandparent' ? config.chargeStrength * 3 : 
                       d.role === 'parent' ? config.chargeStrength * 2 : 
                       config.chargeStrength))
      .force('center', d3.forceCenter(config.width / 2, config.height / 2))
      .force('collision', d3.forceCollide().radius(config.nodeRadius * 2))
      // Add specific force to position nodes in a hierarchical structure
      .force('x', d3.forceX().strength(0.1).x(d => {
        if (d.role === 'grandparent') return config.width / 2;
        if (d.role === 'parent') return config.width / 2;
        return config.width / 2;
      }))
      .force('y', d3.forceY().strength(0.2).y(d => {
        if (d.role === 'grandparent') return config.height / 3;
        if (d.role === 'parent') return config.height / 2;
        return 2 * config.height / 3;
      }))
      .on('tick', simulationTick);

    // Set initial transform
    if (config.initialTransform) {
      state.svg.call(
        state.zoom.transform, 
        d3.zoomIdentity
          .translate(config.initialTransform.x, config.initialTransform.y)
          .scale(config.initialTransform.k)
      );
    }

    // Add CSS for animations
    addStyles();
  }

  // Function to set up drag behavior
  function setupDrag() {
    if (!config.interactive) return function() {};
    
    return d3.drag()
      .on('start', dragStarted)
      .on('drag', dragging)
      .on('end', dragEnded);
  }

  // Drag functions
  function dragStarted(event, d) {
    if (!event.active) state.simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }

  function dragging(event, d) {
    d.fx = event.x;
    d.fy = event.y;
  }

  function dragEnded(event, d) {
    if (!event.active) state.simulation.alphaTarget(0);
    if (!d.fixed) {
      d.fx = null;
      d.fy = null;
    }
  }

  // Update positions on each simulation tick
  function simulationTick() {
    state.linkElements
      .attr('x1', d => d.source.x)
      .attr('y1', d => d.source.y)
      .attr('x2', d => d.target.x)
      .attr('y2', d => d.target.y);

    state.nodeElements
      .attr('transform', d => `translate(${d.x}, ${d.y})`);
  }

  // Get node color based on status
  function getNodeColor(node) {
    // If node has a custom color, use it
    if (node.color) return node.color;
    
    // Otherwise use the default logic
    return node.verified ? config.colors.verified : 
           node.pending ? config.colors.pending : 
           'url(#node-gradient)';
  }

  // Generate random demo data
  function generateDemoNodes() {
    // Create a family structure with grandparent -> parents -> children
    const nodes = [
      // Grandparent (golden central node)
      { id: 'grandparent', name: 'Grandparent', role: 'grandparent', verified: true, fixed: true, color: '#FFD700' },
      
      // Parents (3 purple nodes)
      { id: 'parent1', name: 'Parent 1', role: 'parent', verified: true, color: '#9C27B0' },
      { id: 'parent2', name: 'Parent 2', role: 'parent', verified: true, color: '#9C27B0' },
      { id: 'parent3', name: 'Parent 3', role: 'parent', verified: true, color: '#9C27B0' },
      
      // Children for Parent 1 (blue nodes)
      { id: 'child1-1', name: 'Child 1-1', role: 'child', verified: false, color: '#2196F3' },
      { id: 'child1-2', name: 'Child 1-2', role: 'child', verified: false, color: '#2196F3' },
      { id: 'child1-3', name: 'Child 1-3', role: 'child', verified: false, color: '#2196F3' },
      
      // Children for Parent 2 (blue nodes)
      { id: 'child2-1', name: 'Child 2-1', role: 'child', verified: false, color: '#2196F3' },
      { id: 'child2-2', name: 'Child 2-2', role: 'child', verified: false, color: '#2196F3' },
      { id: 'child2-3', name: 'Child 2-3', role: 'child', verified: false, color: '#2196F3' },
      
      // Children for Parent 3 (blue nodes)
      { id: 'child3-1', name: 'Child 3-1', role: 'child', verified: false, color: '#2196F3' },
      { id: 'child3-2', name: 'Child 3-2', role: 'child', verified: false, color: '#2196F3' },
      { id: 'child3-3', name: 'Child 3-3', role: 'child', verified: false, color: '#2196F3', pulse: true, highlighted: true, name: 'You' }
    ];
    
    return nodes;
  }

  function generateDemoLinks() {
    // Create connections between nodes to form the family tree
    const links = [
      // Grandparent to Parents
      { source: 'grandparent', target: 'parent1', relationship: 'parent', verified: true },
      { source: 'grandparent', target: 'parent2', relationship: 'parent', verified: true },
      { source: 'grandparent', target: 'parent3', relationship: 'parent', verified: true },
      
      // Parent 1 to Children
      { source: 'parent1', target: 'child1-1', relationship: 'parent', verified: false },
      { source: 'parent1', target: 'child1-2', relationship: 'parent', verified: false },
      { source: 'parent1', target: 'child1-3', relationship: 'parent', verified: false },
      
      // Parent 2 to Children
      { source: 'parent2', target: 'child2-1', relationship: 'parent', verified: false },
      { source: 'parent2', target: 'child2-2', relationship: 'parent', verified: false },
      { source: 'parent2', target: 'child2-3', relationship: 'parent', verified: false },
      
      // Parent 3 to Children
      { source: 'parent3', target: 'child3-1', relationship: 'parent', verified: false },
      { source: 'parent3', target: 'child3-2', relationship: 'parent', verified: false },
      { source: 'parent3', target: 'child3-3', relationship: 'parent', verified: false }
    ];
    
    return links;
  }

  // Add CSS styles for animations and effects
  function addStyles() {
    if (document.getElementById('network-visualization-styles')) return;
    
    const styleSheet = document.createElement('style');
    styleSheet.id = 'network-visualization-styles';
    styleSheet.textContent = `
      .network-visualization {
        background: transparent;
      }
      
      .node {
        cursor: pointer;
        transition: transform 0.3s ease;
      }
      
      .node:hover {
        transform: scale(1.1);
      }
      
      .node-circle.pulse {
        animation: pulse 2s infinite;
      }
      
      @keyframes pulse {
        0% {
          transform: scale(1);
          opacity: 1;
        }
        50% {
          transform: scale(1.05);
          opacity: 0.8;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
    `;
    document.head.appendChild(styleSheet);
  }

  // Public API
  return {
    // Update visualization with new data
    update: function(nodes, links) {
      if (nodes) state.nodes = nodes;
      if (links) state.links = links;
      
      // Update the simulation
      state.simulation.nodes(state.nodes);
      state.simulation.force('link').links(state.links);
      
      // Restart the simulation
      state.simulation.alpha(1).restart();
    },

    // Focus on a specific node by ID
    focusNode: function(nodeId) {
      const node = state.nodes.find(n => n.id === nodeId);
      if (!node) return;
      
      // Set initial position of node to the center if not already positioned
      if (!node.x && !node.y) {
        node.x = config.width / 2;
        node.y = config.height / 2;
      }
      
      // Transition to center on the node
      state.svg.transition()
        .duration(750)
        .call(
          state.zoom.transform,
          d3.zoomIdentity
            .translate(config.width / 2, config.height / 2)
            .scale(1.5)
            .translate(-node.x, -node.y)
        );
    },

    // Highlight a path between nodes
    highlightPath: function(startId, endId) {
      // Reset current highlights
      state.nodeElements.select('circle')
        .style('filter', d => d.highlighted ? 'url(#glow)' : 'none');
      
      state.linkElements
        .attr('stroke', config.colors.link)
        .attr('stroke-width', d => d.strength ? 2 + d.strength : 2);
      
      // Find path
      const path = findPath(startId, endId);
      
      // Highlight path nodes and links
      if (path && path.length > 0) {
        // Highlight links in the path
        state.linkElements
          .attr('stroke', d => path.includes(d) ? config.colors.primary : config.colors.link)
          .attr('stroke-width', d => path.includes(d) ? 4 : (d.strength ? 2 + d.strength : 2));
        
        // Highlight nodes in the path
        state.nodeElements.select('circle')
          .style('filter', d => {
            if (d.id === startId || d.id === endId) return 'url(#glow)';
            if (path.some(link => link.source.id === d.id || link.target.id === d.id)) {
              return 'url(#glow)';
            }
            return d.highlighted ? 'url(#glow)' : 'none';
          });
      }
    },

    // Find a simple path between two nodes
    findPath: function(startId, endId) {
      return findPath(startId, endId);
    },

    // Reset the visualization to initial state
    reset: function() {
      state.simulation.alpha(1).restart();
      
      state.svg.transition()
        .duration(750)
        .call(
          state.zoom.transform,
          d3.zoomIdentity
            .translate(config.initialTransform.x, config.initialTransform.y)
            .scale(config.initialTransform.k)
        );
    },

    // Update colors
    updateColors: function(colors) {
      Object.assign(config.colors, colors);
      
      // Update node colors
      state.nodeElements.select('circle')
        .attr('fill', d => getNodeColor(d));
      
      // Update verification indicators
      state.nodeElements.select('circle:nth-child(2)')
        .attr('fill', d => {
          if (d.verified) return config.colors.verified;
          if (d.pending) return config.colors.pending;
          return config.colors.unverified;
        });
      
      // Update links
      state.linkElements
        .attr('stroke', config.colors.link);
    },

    // Get current state of visualization
    getState: function() {
      return {
        nodes: state.nodes,
        links: state.links
      };
    }
  };

  // Helper function to find a path between nodes
  function findPath(startId, endId) {
    const paths = [];
    const visited = new Set();
    
    function dfs(currentId, path) {
      if (currentId === endId) {
        paths.push([...path]);
        return;
      }
      
      visited.add(currentId);
      
      const neighbors = state.links.filter(link => 
        (link.source.id === currentId || link.target.id === currentId)
      );
      
      for (const link of neighbors) {
        const nextId = link.source.id === currentId ? link.target.id : link.source.id;
        
        if (!visited.has(nextId)) {
          path.push(link);
          dfs(nextId, path);
          path.pop();
        }
      }
      
      visited.delete(currentId);
    }
    
    dfs(startId, []);
    
    // Return the shortest path found
    return paths.sort((a, b) => a.length - b.length)[0] || [];
  }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
  const networkVis = createNetworkVisualization('network-visualization');
}); 