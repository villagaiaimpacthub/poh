{% extends "base.html" %}

{% block title %}Proof of Humanity - Human Verification Through Trusted Relationships{% endblock %}

{% block styles %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/index.css') }}?v={{ now().strftime('%Y%m%d%H%M%S') }}">
<style>
  /* Diagnostic styles */
  .debug-box {
    position: fixed;
    top: 10px;
    right: 10px;
    background: rgba(0, 0, 0, 0.8);
    color: lime;
    padding: 10px;
    border-radius: 5px;
    font-family: monospace;
    z-index: 9999;
    max-width: 400px;
    max-height: 300px;
    overflow: auto;
    white-space: pre-wrap;
    font-size: 12px;
    display: none; /* Initially hidden, toggle with the debug-toggle button */
  }
  
  .debug-toggle {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: #7a43ff;
    color: white;
    border: none;
    border-radius: 5px;
    padding: 5px 10px;
    cursor: pointer;
    z-index: 10000;
    font-family: monospace;
  }
  
  /* Diagnostic outlines */
  .debug-mode .hero-section {
    outline: 2px dashed red !important;
  }
  
  .debug-mode .hero-content {
    outline: 2px dashed blue !important;
  }
  
  .debug-mode .hero-visual {
    outline: 2px dashed green !important;
  }
  
  .debug-mode .feature-card, 
  .debug-mode .benefit-card {
    outline: 2px dashed orange !important;
  }
  
  .debug-mode iframe {
    outline: 2px solid magenta !important;
  }
</style>
{% endblock %}

{% block content %}
<div class="debug-box" id="debugBox"></div>

<div class="hero-section">
    <div class="hero-content">
        <h1 class="hero-title">Proof of Humanity</h1>
        <p class="hero-description">
            A social identity verification system built on a web of trust network. Join our community and become part of a revolutionary approach to human verification.
        </p>
        <div class="hero-cta">
            <a href="{{ url_for('register') }}" class="btn-web5">Join Now</a>
            <a href="{{ url_for('about') }}" class="btn-ghost">Learn More</a>
        </div>
    </div>
    <div class="hero-visual">
        <iframe src="{{ url_for('network.viz', _external=True) }}" id="visualization-iframe" frameborder="0" allow="fullscreen" sandbox="allow-scripts allow-same-origin allow-popups allow-forms"></iframe>
    </div>
</div>

<section class="section quote-section">
    <div class="container">
        <blockquote class="quote-card">
            <p>The Proof of Humanity system enables a new era of human verification, where identity is validated through social connections rather than centralized authorities. This creates possibilities for more equitable governance, trustless interactions, and protection against identity fraud and sybil attacks.</p>
            <cite>Inspired by the principles of Web5 and decentralized identity</cite>
        </blockquote>
    </div>
</section>

<section class="section combined-features-benefits">
    <div class="container">
        <div class="section-header">
            <h2>Why Choose Proof of Humanity</h2>
            <p>Key features and benefits that make our approach unique</p>
        </div>
        <div class="features-grid">
            <div class="feature-card">
                <div class="feature-icon">
                    <i class="fas fa-network-wired"></i>
                </div>
                <h3>Web of Trust</h3>
                <p>Build connections in a decentralized trust network where verification happens through trusted human relationships.</p>
            </div>
            <div class="feature-card">
                <div class="feature-icon">
                    <i class="fas fa-shield-alt"></i>
                </div>
                <h3>Sybil Resistance</h3>
                <p>Our multi-layered verification process makes it extremely difficult to create fake identities or impersonate others.</p>
            </div>
            <div class="feature-card">
                <div class="feature-icon">
                    <i class="fas fa-id-card-alt"></i>
                </div>
                <h3>Verification without Government ID</h3>
                <p>Prove your humanity without sharing government identification or other sensitive documents.</p>
            </div>
            <div class="feature-card">
                <div class="feature-icon">
                    <i class="fas fa-bolt"></i>
                </div>
                <h3>One-Time Process</h3>
                <p>Verify once and use your digital identity across multiple platforms without repeated verifications.</p>
            </div>
            <div class="feature-card">
                <div class="feature-icon">
                    <i class="fas fa-lock"></i>
                </div>
                <h3>Privacy Focused</h3>
                <p>Maintain control over your personal information while still participating in a verified community.</p>
            </div>
            <div class="feature-card">
                <div class="feature-icon">
                    <i class="fas fa-users"></i>
                </div>
                <h3>Community Governance</h3>
                <p>Verified users participate in the governance of the system, ensuring fair and transparent decision-making.</p>
            </div>
        </div>
    </div>
</section>

<section class="section stats-section">
    <div class="container">
        <div class="stats-grid grid-cols-3">
            <div class="stat-card">
                <div class="stat-number" data-count="10000">0</div>
                <div class="stat-label">Verified Humans</div>
            </div>
            
            <div class="stat-card">
                <div class="stat-number" data-count="3500">0</div>
                <div class="stat-label">Trust Groups</div>
            </div>
            
            <div class="stat-card">
                <div class="stat-number" data-count="25000">0</div>
                <div class="stat-label">Connections</div>
            </div>
        </div>
    </div>
</section>

<section id="how-it-works" class="section how-it-works">
    <div class="container">
        <div class="section-header-web5">
            <h2 class="section-title-web5">How It Works</h2>
            <p class="section-subtitle-web5">Our human verification system leverages the most reliable network: trusted human connections</p>
        </div>
        
        <div class="steps-container grid-cols-3">
            <div class="card-web5 step-card">
                <div class="step-icon">
                    <i class="fas fa-user-plus"></i>
                </div>
                <h3>1. Join the Network</h3>
                <p>Receive an invite link from someone who trusts you, create your account, and join the trusted verification network.</p>
            </div>
            
            <div class="card-web5 step-card">
                <div class="step-icon">
                    <i class="fas fa-video"></i>
                </div>
                <h3>2. Verify Each Other</h3>
                <p>Schedule and complete a video verification call with a group of 5 humans, guided by our AI assistant.</p>
            </div>
            
            <div class="card-web5 step-card">
                <div class="step-icon">
                    <i class="fas fa-fingerprint"></i>
                </div>
                <h3>3. Get Your Digital ID</h3>
                <p>Once verified by the group, receive your decentralized identifiers (DIDs) that prove your humanity.</p>
            </div>
        </div>
    </div>
</section>

<section class="section faq-section">
    <div class="container">
        <div class="section-header">
            <h2 class="section-title">Frequently Asked Questions</h2>
            <p class="section-subtitle">Get answers to common questions about Proof of Humanity</p>
        </div>
        
        <div class="faq-container">
            <div class="faq-item">
                <div class="faq-question">
                    <h3>What is Proof of Humanity?</h3>
                    <span class="faq-toggle"><i class="fas fa-plus"></i></span>
                </div>
                <div class="faq-answer">
                    <p>Proof of Humanity is a novel approach to verifying human identities in digital spaces. Unlike traditional methods that rely on personal documentation or centralized authorities, we leverage trusted family relationships to create a robust and privacy-preserving verification system.</p>
                </div>
            </div>
            
            <div class="faq-item">
                <div class="faq-question">
                    <h3>How does family verification work?</h3>
                    <span class="faq-toggle"><i class="fas fa-plus"></i></span>
                </div>
                <div class="faq-answer">
                    <p>Users are invited to the network by people who already know and trust them. Together with an AI facilitator, a group of 5 humans are prompted to verify each other's humanity during a live video call. After enough verifications, you receive your DID (decentralized identity) that can be used to validate yourself on any platform that accepts our protocol.</p>
                </div>
            </div>
            
            <div class="faq-item">
                <div class="faq-question">
                    <h3>Is my personal information safe?</h3>
                    <span class="faq-toggle"><i class="fas fa-plus"></i></span>
                </div>
                <div class="faq-answer">
                    <p>Yes. Proof of Humanity is designed with privacy as a core principle. We collect minimal personal information, and the verification process happens between you and trusted individuals, not through a centralized authority. Your data is encrypted and you control who has access to your verification status.</p>
                </div>
            </div>
            
            <div class="faq-item">
                <div class="faq-question">
                    <h3>What if I don't have family members to verify me?</h3>
                    <span class="faq-toggle"><i class="fas fa-plus"></i></span>
                </div>
                <div class="faq-answer">
                    <p>Our system works by creating an unbroken chain of trust. You are invited into a family unit by someone who already knows and trusts you. This creates connections across the entire network where trust is maintained through direct personal relationships. You don't need an "outside family" - the system is designed to build trust through existing connections.</p>
                </div>
            </div>
            
            <div class="faq-item">
                <div class="faq-question">
                    <h3>Where can I use my Proof of Humanity verification?</h3>
                    <span class="faq-toggle"><i class="fas fa-plus"></i></span>
                </div>
                <div class="faq-answer">
                    <p>Your Proof of Humanity verification can be used across any web3 application or service that integrates with our protocol. We're actively partnering with platforms across DeFi, NFT marketplaces, voting systems, and other web3 services to expand the utility of your verification.</p>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="section cta-section">
    <div class="container">
        <div class="cta-card">
            <h2>Ready to Join Our Community?</h2>
            <p>Start your verification journey today and become part of our growing network of verified humans.</p>
            <div class="cta-buttons">
                <a href="{{ url_for('register') }}" class="btn-web5">Sign Up Now</a>
                <a href="{{ url_for('verification_manage') }}" class="btn-ghost">Learn About Verification</a>
            </div>
        </div>
    </div>
</section>

<button class="debug-toggle">Debug</button>

<script>
  // Debug logging function
  function logDebug(message, type = 'info') {
    const debugBox = document.getElementById('debugBox');
    const timestamp = new Date().toISOString().substr(11, 8);
    
    if (!debugBox) return;
    
    const entry = document.createElement('div');
    entry.className = `debug-entry debug-${type}`;
    entry.textContent = `[${timestamp}] [${type}] ${message}`;
    
    if (type === 'error') {
      entry.style.color = '#ff5757';
    } else if (type === 'warning') {
      entry.style.color = '#ffbb00';
    } else if (type === 'success') {
      entry.style.color = '#00ff66';
    }
    
    debugBox.appendChild(entry);
    debugBox.scrollTop = debugBox.scrollHeight;
    
    // Also log to console
    console[type in console ? type : 'log'](message);
  }
  
    document.addEventListener('DOMContentLoaded', function() {
    // Debug toggle functionality
    const debugToggle = document.querySelector('.debug-toggle');
    const debugBox = document.querySelector('.debug-box');
    
    if (debugToggle && debugBox) {
      debugToggle.addEventListener('click', function() {
        document.body.classList.toggle('debug-mode');
        debugBox.style.display = debugBox.style.display === 'none' ? 'block' : 'none';
        logDebug('Debug mode ' + (document.body.classList.contains('debug-mode') ? 'enabled' : 'disabled'));
      });
    }
    
    // Log CSS variables and computed styles
    function logStyles() {
      try {
        const heroSection = document.querySelector('.hero-section');
        const heroContent = document.querySelector('.hero-content');
        const heroVisual = document.querySelector('.hero-visual');
        
        if (heroSection && heroContent && heroVisual) {
          const heroSectionStyles = window.getComputedStyle(heroSection);
          const heroContentStyles = window.getComputedStyle(heroContent);
          const heroVisualStyles = window.getComputedStyle(heroVisual);
          
          logDebug('Hero Section - display: ' + heroSectionStyles.display + 
                   ', grid-template-columns: ' + heroSectionStyles.gridTemplateColumns);
          
          logDebug('Hero Content - display: ' + heroContentStyles.display + 
                   ', width: ' + heroContentStyles.width + 
                   ', max-width: ' + heroContentStyles.maxWidth);
          
          logDebug('Hero Visual - display: ' + heroVisualStyles.display + 
                   ', width: ' + heroVisualStyles.width + 
                   ', height: ' + heroVisualStyles.height);
          
          // Check for grid layout
          if (heroSectionStyles.display !== 'grid') {
            logDebug('Hero section is not displaying as a grid!', 'error');
          }
          
          // Check if media queries are active
          const windowWidth = window.innerWidth;
          logDebug('Window width: ' + windowWidth + 'px');
          if (windowWidth <= 992) {
            logDebug('Media query for <= 992px should be active', 'warning');
          }
          if (windowWidth <= 768) {
            logDebug('Media query for <= 768px should be active', 'warning');
          }
          if (windowWidth <= 576) {
            logDebug('Media query for <= 576px should be active', 'warning');
          }
        }
        
        // Check for style conflicts by inspecting CSS rules
        const allStyles = Array.from(document.styleSheets).filter(sheet => {
          try {
            // Access cssRules to check if it's a same-origin stylesheet
            return sheet.cssRules;
          } catch (e) {
            // This will throw an error for cross-origin stylesheets
            return false;
          }
        });
        
        let conflictingRules = [];
        allStyles.forEach(sheet => {
          Array.from(sheet.cssRules).forEach(rule => {
            if (rule.selectorText && 
                (rule.selectorText.includes('hero-section') || 
                 rule.selectorText.includes('hero-content') || 
                 rule.selectorText.includes('hero-visual'))) {
              conflictingRules.push(rule.selectorText);
            }
          });
        });
        
        if (conflictingRules.length > 0) {
          logDebug('Potentially conflicting CSS rules found: ' + conflictingRules.join(', '), 'warning');
        }
      } catch (error) {
        logDebug('Error inspecting styles: ' + error.message, 'error');
      }
    }
    
    // Log style information after a short delay
    setTimeout(logStyles, 1000);
    
    // Check if hero visualization iframe loads correctly
    const vizIframe = document.querySelector('#visualization-iframe');
    if (vizIframe) {
      logDebug('Visualization iframe found, monitoring for load events');
      
      // Set a timeout to check if the iframe loaded
      const timeoutId = setTimeout(() => {
        logDebug('Network visualization timed out after 5 seconds', 'error');
        addFallbackVisualization();
      }, 5000);
      
      // Listen for iframe load success
      vizIframe.addEventListener('load', function() {
        clearTimeout(timeoutId);
        logDebug('Visualization iframe load event fired', 'success');
        
        // Check if the iframe actually has content
        try {
          const iframeDocument = vizIframe.contentDocument || vizIframe.contentWindow.document;
          if (iframeDocument) {
            const networkNodes = iframeDocument.querySelectorAll('#network circle');
            logDebug(`Found ${networkNodes.length} network nodes in iframe`);
            if (networkNodes.length === 0) {
              logDebug('Visualization iframe loaded but contains no network nodes', 'warning');
              // Wait a bit more to see if D3 is still initializing
              setTimeout(() => {
                const updatedNodes = iframeDocument.querySelectorAll('#network circle');
                if (updatedNodes.length === 0) {
                  logDebug('No nodes appeared after delay, falling back to static visualization', 'error');
                  addFallbackVisualization();
                } else {
                  logDebug(`Found ${updatedNodes.length} nodes after delay`, 'success');
                }
              }, 2000);
            }
          }
        } catch (e) {
          logDebug('Error accessing iframe content: ' + e.message, 'error');
          logDebug('This may indicate a cross-origin issue', 'warning');
        }
        
        // Add specific size requirements to ensure proper display
        vizIframe.style.width = '100%';
        vizIframe.style.height = '100%';
        vizIframe.style.minHeight = '500px';
        logDebug('Applied explicit dimensions to iframe');
      });
      
      // Listen for iframe load error
      vizIframe.addEventListener('error', function(e) {
        clearTimeout(timeoutId);
        logDebug('Network visualization failed to load: ' + (e.message || 'Unknown error'), 'error');
        addFallbackVisualization();
      });
      
      // Listen for messages from the iframe
      window.addEventListener('message', function(event) {
        if (event.data === 'viz-iframe-loaded') {
          logDebug('Received "viz-iframe-loaded" message from iframe', 'success');
        }
      });
    } else {
      logDebug('Visualization iframe not found in DOM', 'error');
    }
    
    function addFallbackVisualization() {
      const vizContainer = document.querySelector('.hero-visual');
      if (vizContainer) {
        logDebug('Adding fallback visualization', 'warning');
        // Create a fallback visualization
        vizContainer.innerHTML = `
          <div class="fallback-visualization">
            <svg width="100%" height="100%" viewBox="0 0 800 600" xmlns="http://www.w3.org/2000/svg">
              <defs>
                <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%">
                  <stop offset="0%" stop-color="#7a43ff" stop-opacity="0.7" />
                  <stop offset="100%" stop-color="#43d1ff" stop-opacity="0.7" />
                </linearGradient>
              </defs>
              <g class="nodes">
                <circle cx="400" cy="300" r="40" fill="url(#grad1)" />
                <circle cx="250" cy="200" r="20" fill="#7a43ff" opacity="0.7" />
                <circle cx="550" cy="200" r="20" fill="#7a43ff" opacity="0.7" />
                <circle cx="250" cy="400" r="20" fill="#7a43ff" opacity="0.7" />
                <circle cx="550" cy="400" r="20" fill="#7a43ff" opacity="0.7" />
                <circle cx="150" cy="300" r="15" fill="#43d1ff" opacity="0.7" />
                <circle cx="650" cy="300" r="15" fill="#43d1ff" opacity="0.7" />
                <circle cx="350" cy="120" r="15" fill="#43d1ff" opacity="0.7" />
                <circle cx="450" cy="120" r="15" fill="#43d1ff" opacity="0.7" />
                <circle cx="350" cy="480" r="15" fill="#43d1ff" opacity="0.7" />
                <circle cx="450" cy="480" r="15" fill="#43d1ff" opacity="0.7" />
              </g>
              <g class="links" stroke-width="1" stroke-opacity="0.6">
                <line x1="400" y1="300" x2="250" y2="200" stroke="#7a43ff" />
                <line x1="400" y1="300" x2="550" y2="200" stroke="#7a43ff" />
                <line x1="400" y1="300" x2="250" y2="400" stroke="#7a43ff" />
                <line x1="400" y1="300" x2="550" y2="400" stroke="#7a43ff" />
                <line x1="250" y1="200" x2="150" y2="300" stroke="#43d1ff" />
                <line x1="550" y1="200" x2="650" y2="300" stroke="#43d1ff" />
                <line x1="250" y1="200" x2="350" y2="120" stroke="#43d1ff" />
                <line x1="550" y1="200" x2="450" y2="120" stroke="#43d1ff" />
                <line x1="250" y1="400" x2="350" y2="480" stroke="#43d1ff" />
                <line x1="550" y1="400" x2="450" y2="480" stroke="#43d1ff" />
              </g>
            </svg>
          </div>
        `;
        logDebug('Fallback visualization added successfully', 'success');
        
        // Check if fallback is visible
        setTimeout(() => {
          const fallbackViz = document.querySelector('.fallback-visualization');
          if (fallbackViz) {
            const fallbackStyles = window.getComputedStyle(fallbackViz);
            logDebug('Fallback visibility: ' + fallbackStyles.display + 
                    ', width: ' + fallbackStyles.width + 
                    ', height: ' + fallbackStyles.height);
          }
        }, 500);
      } else {
        logDebug('Hero visual container not found, cannot add fallback', 'error');
      }
    }
    
    // Log which stylesheet versions are loaded
    const stylesheets = Array.from(document.querySelectorAll('link[rel="stylesheet"]'));
    stylesheets.forEach(sheet => {
      logDebug('Stylesheet: ' + sheet.href);
    });

    // Log calculated dimensions of key elements
    function logElementDimensions() {
      const elements = [
        { selector: '.hero-section', name: 'Hero Section' },
        { selector: '.hero-content', name: 'Hero Content' },
        { selector: '.hero-visual', name: 'Hero Visual' },
        { selector: '.hero-visual iframe', name: 'Visualization Iframe' },
        { selector: '.feature-card', name: 'Feature Card' },
        { selector: '.benefit-card', name: 'Benefit Card' }
      ];
      
      elements.forEach(el => {
        const element = document.querySelector(el.selector);
        if (element) {
          const rect = element.getBoundingClientRect();
          logDebug(`${el.name}: width=${rect.width}px, height=${rect.height}px, top=${rect.top}px, left=${rect.left}px`);
        } else {
          logDebug(`${el.name} not found in DOM`, 'warning');
        }
      });
    }
    
    // Run dimension logging after styles have been applied
    setTimeout(logElementDimensions, 1500);

    // Add this to the beginning of the script to check CSS loading status
    document.addEventListener('DOMContentLoaded', function() {
      // Create a diagnostic tool for CSS inspection
      const cssInspector = {
        init: function() {
          logDebug('CSS Inspector initialized', 'info');
          this.checkStylesheetLoading();
          this.checkCssVariables();
          this.checkMainCssRules();
          this.checkImportantRules();
        },
        
        checkStylesheetLoading: function() {
          const stylesheets = Array.from(document.styleSheets);
          logDebug(`Found ${stylesheets.length} stylesheets`);
          
          // Check main.css and index.css specifically
          const mainCss = stylesheets.find(sheet => sheet.href && sheet.href.includes('main.css'));
          const indexCss = stylesheets.find(sheet => sheet.href && sheet.href.includes('index.css'));
          
          if (mainCss) {
            logDebug('main.css is loaded: ' + mainCss.href, 'success');
            try {
              // Check if we can access rules (same-origin)
              const rules = mainCss.cssRules || mainCss.rules;
              logDebug(`main.css has ${rules.length} rules`);
            } catch (e) {
              logDebug('Cannot access main.css rules due to CORS: ' + e.message, 'warning');
            }
          } else {
            logDebug('main.css not found!', 'error');
          }
          
          if (indexCss) {
            logDebug('index.css is loaded: ' + indexCss.href, 'success');
            try {
              // Check if we can access rules (same-origin)
              const rules = indexCss.cssRules || indexCss.rules;
              logDebug(`index.css has ${rules.length} rules`);
            } catch (e) {
              logDebug('Cannot access index.css rules due to CORS: ' + e.message, 'warning');
            }
          } else {
            logDebug('index.css not found!', 'error');
          }
        },
        
        checkCssVariables: function() {
          const root = document.documentElement;
          const style = getComputedStyle(root);
          
          // Check some key CSS variables
          const cssVars = [
            '--primary', '--secondary', '--color-bg', '--color-surface', 
            '--web5-primary', '--web5-accent', '--color-text'
          ];
          
          let foundVars = 0;
          cssVars.forEach(varName => {
            const value = style.getPropertyValue(varName).trim();
            if (value) {
              logDebug(`CSS Variable ${varName}: ${value}`, 'success');
              foundVars++;
            } else {
              logDebug(`CSS Variable ${varName} not found`, 'warning');
            }
          });
          
          if (foundVars === 0) {
            logDebug('No CSS variables found - potential issue with stylesheets', 'error');
          }
        },
        
        checkMainCssRules: function() {
          // Check if key styles from main.css are applied
          const selectors = [
            '.container', '.hero-section', '.btn-web5', '.btn-ghost'
          ];
          
          selectors.forEach(selector => {
            const element = document.querySelector(selector);
            if (element) {
              const style = window.getComputedStyle(element);
              logDebug(`${selector} - display: ${style.display}, position: ${style.position}, bg-color: ${style.backgroundColor}`);
                } else {
              logDebug(`Element with selector "${selector}" not found in DOM`, 'warning');
            }
          });
        },
        
        checkImportantRules: function() {
          // Count !important declarations to detect specificity wars
          try {
            let importantCount = 0;
            const sheets = Array.from(document.styleSheets).filter(sheet => {
              try {
                return sheet.cssRules; // This will fail for cross-origin sheets
              } catch (e) {
                return false;
              }
            });
            
            sheets.forEach(sheet => {
              Array.from(sheet.cssRules).forEach(rule => {
                if (rule.cssText && rule.cssText.includes('!important')) {
                  importantCount++;
                }
            });
        });
        
            logDebug(`Found ${importantCount} !important declarations`, importantCount > 50 ? 'warning' : 'info');
          } catch (e) {
            logDebug('Error checking !important rules: ' + e.message, 'error');
          }
        }
      };
      
      // Run our CSS diagnostics
      setTimeout(() => {
        cssInspector.init();
      }, 500);
      
      // Add listener for iframe messages from the visualization
      window.addEventListener('message', function(event) {
        if (event.data && event.data.type === 'viz-log') {
          logDebug(`[Viz Frame] ${event.data.message}`, event.data.logType || 'info');
        }
      });
    });
  });
</script>
{% endblock %}

{% block scripts %}
{{ super() }}
<script src="{{ url_for('static', filename='js/network-visualization.js') }}"></script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        console.log("Index page loaded - Running diagnostics");
        
        // Debug button test
        const debugButton = document.querySelector('.debug-button');
        if (debugButton) {
            console.log("Debug button found:", debugButton);
            debugButton.addEventListener('click', function(e) {
                console.log("Debug button clicked", e);
                alert("Debug button clicked - This alert confirms the button works");
            });
        } else {
            console.error("Debug button not found in the DOM");
            
            // Create fallback debug button
            const fallbackButton = document.createElement('button');
            fallbackButton.className = 'debug-button';
            fallbackButton.textContent = 'Debug';
            fallbackButton.style.cssText = `
                position: fixed;
                top: 10px;
                right: 10px;
                z-index: 9999;
                background-color: #7a43ff;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
            `;
            fallbackButton.addEventListener('click', function() {
                console.log("Fallback debug button clicked");
                alert("Fallback debug button clicked");
            });
            document.body.appendChild(fallbackButton);
            console.log("Created fallback debug button");
        }
        
        // Check CSS variables
        const root = document.documentElement;
        const computedStyle = getComputedStyle(root);
        
        console.log("CSS Variables check:");
        console.log("--dark-bg:", computedStyle.getPropertyValue('--dark-bg'));
        console.log("--dark-surface:", computedStyle.getPropertyValue('--dark-surface'));
        
        // Check if dark mode is applied to elements
        const bgColor = getComputedStyle(document.body).backgroundColor;
        console.log("Body background color:", bgColor);
        
        // Check hero section elements
        const heroSection = document.querySelector('.hero-section');
        if (heroSection) {
            console.log("Hero section found with background:", getComputedStyle(heroSection).backgroundColor);
        } else {
            console.error("Hero section not found");
        }
        
        // Check if iframe exists and loads
        const heroVisual = document.querySelector('.hero-visual iframe');
        if (heroVisual) {
            console.log("Hero visualization iframe found:", heroVisual);
            
            // Add loading and error handlers
            heroVisual.addEventListener('load', function() {
                console.log("Iframe loaded successfully");
            });
            
            heroVisual.addEventListener('error', function(e) {
                console.error("Iframe failed to load:", e);
            });
        } else {
            console.error("Hero visualization iframe not found");
        }
    });
</script>
{% endblock %} 